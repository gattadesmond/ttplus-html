<div class="container-fluid text-center">
  <!-- Stack the columns on mobile by making one full-width and the other half-width -->
  <div class="row">
    <div class="col-12 col-lg-4">
      <div class="">&nbsp;</div>
      @@include('_BlockSelectDay.html')
      <div class="">&nbsp;</div>
      @@include('_BlockWidgetInfo.html', { "data": [ { "title": "462", "total":
      "1000", "text": "Walking ", "value": " 1000 steps" }, { "title": "239",
      "total" : "800", "text": "Calories Burn ", "value": "800" }, { "title":
      "2", "total" : "10", "text": "Weight Loss " , "value" : '10 kg'} ] })

      <div class="widget-info-btn mt-4">
        <a
          class="btn btn-primary btn-lg btn-custom-1"
          href="block1-step1.html"
          role="button"
        >
          Start your day</a
        >
      </div>
    </div>
    <div class="col-12 col-lg-4" style="align-self: center">
      <div class="people-wrap">
        <div class="chat-bubble">
          <div class="text fs-5">
            Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do
            eiusmod tempor incididunt ut labore et dolore magna aliqua. Quis
            ipsum suspendisse ultrices gravida. Risus commodo viverra maecenas
            accumsan lacus vel facilisis.
          </div>
        </div>
        <div class="people-main" id="container">
          <!-- <script type="module" src="https://unpkg.com/@splinetool/viewer@0.9.273/build/spline-viewer.js"></script>
          <spline-viewer loading-anim url="https://prod.spline.design/22d5TARPKS1f2ykK/scene.splinecode"></spline-viewer> -->

          <!-- <script type="module" src="https://unpkg.com/@splinetool/viewer@0.9.273/build/spline-viewer.js"></script> -->
          <!-- <script type="module" src="@@webRoot/assets/img/fitness/media/spline-viewer.js"></script> -->
          <!-- <spline-viewer loading-anim url="@@webRoot/assets/img/fitness/media/scene.splinecode"></spline-viewer> -->

          <!-- <img
            src="@@webRoot/assets/img/fitness/model.png"
            class="img-fluid img"
          /> -->
        </div>

        <a class="cta-idle" style="cursor: pointer">Idle</a>
        <a class="cta-walk" style="cursor: pointer">Walk</a>
        <a class="cta-run" style="cursor: pointer">Run</a>
      </div>
    </div>

    <div class="col-12 col-lg-4">
      <div class="stat-container">
        <div class="chat-buble-space">&nbsp;</div>
        <div class="daily-goal mt-4">
          <div class="text-color-2 txt1 text-center">DAILY GOAL</div>
          <div class="text-color-2 txt2 text-center">
            <span class="counter">35</span><span class="txt3">%</span>
          </div>
        </div>

        <div class="stat">
          <div class="stat-item">
            <div class="icon">
              <img
                src="@@webRoot/assets/img/fitness/Vector Smart Object.png"
                class="img-fluid"
                width="60"
              />
            </div>
            <div class="txt1 text-color-2 fw-bold fs-4">1820</div>
            <div class="txt2">Calories</div>
          </div>

          <div class="stat-item">
            <div class="icon">
              <img
                src="@@webRoot/assets/img/fitness/Vector Smart Object-1.png"
                class="img-fluid"
                width="70"
              />
            </div>
            <div class="txt1 text-color-2 fw-bold fs-4">3248</div>
            <div class="txt2">Steps</div>
          </div>

          <div class="stat-item">
            <div class="icon">
              <img
                src="@@webRoot/assets/img/fitness/Vector Smart Object-2.png"
                class="img-fluid"
                width="80"
              />
            </div>
            <div class="txt1 text-color-2 fw-bold fs-4">6.5</div>
            <div class="txt2">Hours</div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script
  async
  src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"
></script>

<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/"
    }
  }
</script>

<script type="module">
  import * as THREE from "three";

  // import Stats from "three/addons/libs/stats.module.js";
  import { GUI } from "three/addons/libs/lil-gui.module.min.js";
  import { OrbitControls } from "three/addons/controls/OrbitControls.js";
  import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";

  let scene, renderer, camera;
  let model, skeleton, mixer, clock;

  const crossFadeControls = [];

  let currentBaseAction = "idle";

  const allActions = [];
  const baseActions = {
    idle: { weight: 1 },
    walk: { weight: 0 },
    run: { weight: 0 },
  };
  const additiveActions = {
    sneak_pose: { weight: 0 },
    sad_pose: { weight: 0 },
    agree: { weight: 0 },
    headShake: { weight: 0 },
  };
  let panelSettings, numAnimations;

  init();

  function init() {
    const container = document.getElementById("container");
    clock = new THREE.Clock();
    scene = new THREE.Scene();
    // scene.background = new THREE.Color("rgba(255, 255, 255, 0)");
    scene.fog = new THREE.Fog(0xa0a0a0, 10, 50);

    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444);
    hemiLight.position.set(0, 20, 0);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffffff);
    dirLight.position.set(3, 10, 10);
    dirLight.castShadow = true;
    dirLight.shadow.camera.top = 2;
    dirLight.shadow.camera.bottom = -2;
    dirLight.shadow.camera.left = -2;
    dirLight.shadow.camera.right = 2;
    dirLight.shadow.camera.near = 0.1;
    dirLight.shadow.camera.far = 40;
    scene.add(dirLight);

    // ground

    const mesh = new THREE.Mesh(
      new THREE.PlaneGeometry(100, 100),
      new THREE.MeshPhongMaterial({
        color: 0x999999,
        depthWrite: false,
      })
    );
    mesh.rotation.x = -Math.PI / 2;
    mesh.receiveShadow = true;
    // scene.add(mesh);

    const loader = new GLTFLoader();
    loader.load("assets/img/models/Xbot.glb", function (gltf) {
      model = gltf.scene;
      scene.add(model);
      model.traverse(function (object) {
        if (object.isMesh) object.castShadow = true;
      });

      skeleton = new THREE.SkeletonHelper(model);
      skeleton.visible = false;
      scene.add(skeleton);

      const animations = gltf.animations;
      mixer = new THREE.AnimationMixer(model);

      numAnimations = animations.length;

      for (let i = 0; i !== numAnimations; ++i) {
        let clip = animations[i];
        const name = clip.name;

        if (baseActions[name]) {
          const action = mixer.clipAction(clip);
          activateAction(action);
          baseActions[name].action = action;
          allActions.push(action);
        } else if (additiveActions[name]) {
          // Make the clip additive and remove the reference frame
          THREE.AnimationUtils.makeClipAdditive(clip);

          if (clip.name.endsWith("_pose")) {
            clip = THREE.AnimationUtils.subclip(clip, clip.name, 2, 3, 30);
          }

          const action = mixer.clipAction(clip);
          activateAction(action);
          additiveActions[name].action = action;
          allActions.push(action);
        }
      }

      // createPanel();

      animate();

      prepareCrossFade(
        baseActions["idle"].action,
        baseActions["walk"].action,
        0.35
      );

      // const currentAction = currentSettings ? currentSettings.action : null;
      // const action = settings ? settings.action : null;

      // if (currentAction !== action) {
      //   prepareCrossFade(currentAction, action, 0.35);
      // }

      var ctaIdle = document.querySelector(".cta-idle");
      ctaIdle.addEventListener("click", function (event) {
        event.preventDefault();
        prepareCrossFade(
          baseActions[currentBaseAction].action,
          baseActions["idle"].action,
          0.35
        );
      });

      var ctaIdle = document.querySelector(".cta-walk");
      ctaIdle.addEventListener("click", function (event) {
        event.preventDefault();
        prepareCrossFade(
          baseActions[currentBaseAction].action,
          baseActions["walk"].action,
          0.35
        );
      });

      var ctaIdle = document.querySelector(".cta-run");
      ctaIdle.addEventListener("click", function (event) {
        event.preventDefault();
        prepareCrossFade(
          baseActions[currentBaseAction].action,
          baseActions["run"].action,
          0.35
        );
      });
    });

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setClearColor(0xffffff, 0);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(330, 540);
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.shadowMap.enabled = true;

    container.appendChild(renderer.domElement);

    // camera
    camera = new THREE.PerspectiveCamera(40, 330 / 540, 1, 100);
    camera.position.set(0, 1, 3);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enablePan = false;
    controls.enableZoom = false;
    controls.target.set(0, 0.9, 0);
    controls.minPolarAngle = Math.PI * 0.4;
    controls.maxPolarAngle = Math.PI * 0.6;
    controls.minAzimuthAngle = -Math.PI * 0.3;
    controls.maxAzimuthAngle = Math.PI * 0.3;
    controls.update();

    // stats = new Stats();
    // container.appendChild(stats.dom);

    window.addEventListener("resize", onWindowResize);
  }

  function createPanel() {
    const panel = new GUI({ width: 310 });

    const folder1 = panel.addFolder("Base Actions");
    const folder2 = panel.addFolder("Additive Action Weights");
    const folder3 = panel.addFolder("General Speed");

    panelSettings = {
      "modify time scale": 1.0,
    };

    const baseNames = ["None", ...Object.keys(baseActions)];

    for (let i = 0, l = baseNames.length; i !== l; ++i) {
      const name = baseNames[i];
      const settings = baseActions[name];
      panelSettings[name] = function () {
        const currentSettings = baseActions[currentBaseAction];

        const currentAction = currentSettings ? currentSettings.action : null;
        const action = settings ? settings.action : null;

        if (currentAction !== action) {
          prepareCrossFade(currentAction, action, 0.35);
        }
      };

      crossFadeControls.push(folder1.add(panelSettings, name));
    }

    for (const name of Object.keys(additiveActions)) {
      const settings = additiveActions[name];

      panelSettings[name] = settings.weight;
      folder2
        .add(panelSettings, name, 0.0, 1.0, 0.01)
        .listen()
        .onChange(function (weight) {
          setWeight(settings.action, weight);
          settings.weight = weight;
        });
    }

    folder3
      .add(panelSettings, "modify time scale", 0.0, 1.5, 0.01)
      .onChange(modifyTimeScale);

    folder1.open();
    folder2.open();
    folder3.open();

    crossFadeControls.forEach(function (control) {
      control.setInactive = function () {
        control.domElement.classList.add("control-inactive");
      };

      control.setActive = function () {
        control.domElement.classList.remove("control-inactive");
      };

      const settings = baseActions[control.property];

      if (!settings || !settings.weight) {
        control.setInactive();
      }
    });
  }

  function activateAction(action) {
    const clip = action.getClip();
    const settings = baseActions[clip.name] || additiveActions[clip.name];
    setWeight(action, settings.weight);
    action.play();
  }

  function modifyTimeScale(speed) {
    mixer.timeScale = speed;
  }

  function prepareCrossFade(startAction, endAction, duration) {
    // If the current action is 'idle', execute the crossfade immediately;
    // else wait until the current action has finished its current loop
    // prepareCrossFade(currentAction, action, 0.35);
    if (currentBaseAction === "idle" || !startAction || !endAction) {

      executeCrossFade(startAction, endAction, duration);
    } else {
      synchronizeCrossFade(startAction, endAction, duration);
    }

    // Update control colors

    if (endAction) {
      const clip = endAction.getClip();
      currentBaseAction = clip.name;
    } else {
      currentBaseAction = "None";
    }

    crossFadeControls.forEach(function (control) {
      const name = control.property;

      if (name === currentBaseAction) {
        control.setActive();
      } else {
        control.setInactive();
      }
    });
    console.log("ðŸš€ ~ file: _content1.html:367 ~ prepareCrossFade ~ currentBaseAction:", currentBaseAction)
    // console.log(currentBaseAction)
  }

  function synchronizeCrossFade(startAction, endAction, duration) {
    mixer.addEventListener("loop", onLoopFinished);

    function onLoopFinished(event) {
      if (event.action === startAction) {
        mixer.removeEventListener("loop", onLoopFinished);

        executeCrossFade(startAction, endAction, duration);
      }
    }
  }

  function executeCrossFade(startAction, endAction, duration) {
    // Not only the start action, but also the end action must get a weight of 1 before fading
    // (concerning the start action this is already guaranteed in this place)

    if (endAction) {
      setWeight(endAction, 1);
      endAction.time = 0;

      if (startAction) {
        // Crossfade with warping

        startAction.crossFadeTo(endAction, duration, true);
      } else {
        // Fade in

        endAction.fadeIn(duration);
      }
    } else {
      // Fade out

      startAction.fadeOut(duration);
    }
  }

  // This function is needed, since animationAction.crossFadeTo() disables its start action and sets
  // the start action's timeScale to ((start animation's duration) / (end animation's duration))

  function setWeight(action, weight) {
    action.enabled = true;
    action.setEffectiveTimeScale(1);
    action.setEffectiveWeight(weight);
  }

  function onWindowResize() {
    camera.aspect = 330 / 540;
    camera.updateProjectionMatrix();

    renderer.setSize(330, 540);
  }

  function animate() {
    // Render loop
    requestAnimationFrame(animate);

    for (let i = 0; i !== numAnimations; ++i) {
      const action = allActions[i];
      const clip = action.getClip();
      const settings = baseActions[clip.name] || additiveActions[clip.name];
      settings.weight = action.getEffectiveWeight();
    }

    // Get the time elapsed since the last frame, used for mixer update

    const mixerUpdateDelta = clock.getDelta();

    // Update the animation mixer, the stats panel, and render this frame

    mixer.update(mixerUpdateDelta);

    // stats.update();

    renderer.render(scene, camera);
  }
</script>
